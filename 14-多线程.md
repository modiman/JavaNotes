# 14-多线程

# 1.线程的概念



# 14.4 线程属性

## 14.4.1 线程优先级

- 线程继承父线程的优先级

- setPriority可以设置线程优先级，可以设置为1-10之间的值

## 14.4.2 守护线程

- 使用t.setDaemon(true)调用

守护线程的唯一用途就是为其他线程提供服务。

## 14.4.3 未捕获异常处理器

# 14.5 同步

## 14.5.2 详解竞争条件

假设两个线程都要执行以下语句

- 取出accounts

- accounts += 500

- 放回accounts

如果线程一执行完前两步就被剥夺了运行权，线程二执行结束后线程一又执行了第三步，那么线程二所做的修改将被抹去

## 14.5.3 锁对象

从java se 5以后，有两种机制防止代码块受并发控制的干扰。

- synchronized关键字

- 14.5.5 synchronized关键字

- volatile能保证数据的可见性，但不能完全保证数据的原子性，

- synchronized即保证了数据的可见性也保证了原子性





（645页）

- 锁用来保护代码片段，任何时刻只能有一个线程执行被保护的代码

- 所可以管理试图进入被保护代码的线程

- 锁可以拥有一个或多个相关的条件对象

- 每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程

如果一个方法使用synchronized声明，那么对象的锁将保护整个方法，也就是说，要调用该方法，线程必须获得对象的内部锁

## 14.5.8 volatile域

有时，仅仅需要读写一两个实例域就使用同步，显得开销太大了。

***\*volatile关键字为实例域的同步访问提供了一种免锁机制\**，如果声明一个域为volatile，那么编译器和虚拟机就知道该域是可能被另一个进程并发更新的**

volatile变量不能提供原子性，

总之，在以下三种情况下域的并发访问是安全的

1. 域是final,并且在构造完成后被访问

2. 对域的访问由共有的锁进行保护

3. 域是valatile的

## 14.10 同步器



同步器



类

它能做什么

何时使用

CyclicBarrier

允许线程集等待直至其中预定数目的线程到达一个公共障栏，然后可以选择执行一个处理障栏的动作

当大量的线程需要在他们的结果可用之前完成时
